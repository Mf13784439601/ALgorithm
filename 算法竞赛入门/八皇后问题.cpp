//#include<iostream>
//#include<cstdio>
//#include<cstdlib>
//
//using namespace std;
//
////当把问题分成若干个步骤并递归求解时，如果当前步骤没有合法选择，则函数将返回上一级递归调用，这种现象称为回溯。
////正是因为这个原因，递归枚举算法常被称为回溯法，应用十分普遍
//
////下面的程序简洁地求解了八皇后问题。在主程序中读入n，并为tot 清零，然后调用 search(0)， 即可得到解地个数tot
//int n;
//int tot = 0;
//
//void search(int cur) {
//	if (cur == n)
//		tot++;//递归边界。只要走到这里，所有皇后必然不冲突
//	else {
//		for (int i = 0; i < n; i++) {
//			int ok = 1;
//			C[cur] = i;//尝试把第cur 行的皇后放在第 i 列
//			for (int j = 0; j < cur; j++) {//检查是否和前面的皇后冲突
//				if (C[cur] == C[j] || cur - C[cur] == j - C[j] || cur + C[cur] == j + C[j]) {
//					ok = 0;
//					break;
//				}
//			}
//			if (ok)
//				search(cur + 1);//如果合法，则继续递归
//		}
//	}
//}//注意： 既然是逐行放置的，则皇后肯定不会横向攻击，因此只需检查是否纵向和横向攻击即可  。条件“cur-C[cur]==j-C[j]||cur+C[cur]==j+C[j]”用来
////判断皇后（cur,C[cur]）和(j,C[j])是否在同一条对角线上。
//
////结点数似乎很难进一步减少了，单程序效率可以继续提高：利用二维数组 vis[2][]直接判断当前尝试的皇后所在的列和两个对角线是否已有其它皇后。
////注意到主对角线标识 y-x 可能为负，存取时需要加上n
//void search2(int cur) {
//	if (cur == n)
//		tot++;
//	else {
//		for (int i = 0; i < n; i++) {
//			if (!vis[0][i] && !vis[1][cur + i] && !vis[2][cur - i + n]) {
//				//利用二维数组直接判断
//				C[cur] = i;//如果不用打印解，整个C 数组都可以省略
//				vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;//修改全局变量
//				search2(cur + 1);
//				vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;//切记  一定要改回来
//			}
//		}
//	}
//}//上面的程序有个极其关键的地方：vis 数组的使用。vis 数组的确切含义是什么？它表示已经放置的皇后占据了哪些列、主对角线和副对角线。
////将来放置的皇后不应该修改这些值-“至少看上去没有修改”。一般地，如果在回溯中修改了辅助的全局变量，则一定要及时把它们恢复原状（除非故意保留所作修改）
//
